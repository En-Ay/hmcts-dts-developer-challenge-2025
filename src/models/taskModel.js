const db = require('../config/db');

// Utility to wrap sqlite3 queries in Promises
const runQuery = (query, params = []) => {
  return new Promise((resolve, reject) => {
    db.run(query, params, function (err) {
      if (err) reject(err);
      else resolve(this);
    });
  });
};

const getQuery = (query, params = []) => {
  return new Promise((resolve, reject) => {
    db.all(query, params, (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    });
  });
};

// The Model Methods
const TaskModel = {
  create: async (task) => {
      const sql = `INSERT INTO tasks (title, description, status, due_date) VALUES (?, ?, ?, ?)`;
      const result = await runQuery(sql, [task.title, task.description, task.status, task.due_date]);
      
      // NEW: Automatically log the creation event
      // We use result.lastID because the ID is generated by the DB
      await TaskModel.addHistory(result.lastID, "Task created");

      return { id: result.lastID, ...task };
    },
  // Enhanced Find All with Filtering and Sorting
  findAll: async ({ statusFilters = [], sortBy = 'due_date', sortOrder = 'ASC' } = {}) => {
    // 1. Security: Whitelist Sort Columns
    const validSorts = ['id', 'title', 'status', 'due_date', 'created_at'];
    const validOrders = ['ASC', 'DESC'];

    const safeSort = validSorts.includes(sortBy) ? sortBy : 'due_date';
    const safeOrder = validOrders.includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'ASC';

    // 2. Base Query
    let sql = `SELECT * FROM tasks WHERE deleted_at IS NULL`;
    const params = [];

    // 3. Status & Overdue Logic
    if (statusFilters.length > 0) {
      // Separate "Real" DB statuses from the "Virtual" OVERDUE status
      const isOverdueSelected = statusFilters.includes('OVERDUE');
      const dbStatuses = statusFilters.filter(s => s !== 'OVERDUE');

      const orConditions = [];

      // Logic A: Standard Statuses (PENDING, IN_PROGRESS, COMPLETED)
      if (dbStatuses.length > 0) {
        const placeholders = dbStatuses.map(() => '?').join(', ');
        orConditions.push(`status IN (${placeholders})`);
        params.push(...dbStatuses);
      }

      // Logic B: Overdue (Due date is in past AND not completed)
      // We pass the current ISO time to compare against the stored string
      if (isOverdueSelected) {
        orConditions.push(`(due_date < ? AND status != 'COMPLETED')`);
        params.push(new Date().toISOString());
      }

      // Combine A and B with OR (e.g. Show me PENDING tasks OR OVERDUE tasks)
      if (orConditions.length > 0) {
        sql += ` AND (${orConditions.join(' OR ')})`;
      }
    }

    // 4. Apply Sort
    sql += ` ORDER BY ${safeSort} ${safeOrder}`;

    return await getQuery(sql, params);
  },
  findById: async (id) => {
    // SECURITY: Prevent accessing a deleted task via direct URL
    const result = await getQuery(`SELECT * FROM tasks WHERE id = ? AND deleted_at IS NULL`, [id]);
    return result[0];
  },

  update: async (id, task) => {
    // SECURITY: Ensure we don't accidentally update a deleted task
    // We add 'AND deleted_at IS NULL' to the WHERE clause
    const sql = `UPDATE tasks SET title = ?, description = ?, status = ?, due_date = ?, updated_at = ? WHERE id = ? AND deleted_at IS NULL`;
    
    await runQuery(sql, [task.title, task.description, task.status, task.due_date, task.updated_at, id]);
    
    return await TaskModel.findById(id);
  },

  delete: async (id) => {
    // SOFT DELETE: Mark as deleted instead of removing the row
    // We use CURRENT_TIMESTAMP to record exactly when it happened (Audit Trail)
    return await runQuery(`UPDATE tasks SET deleted_at = CURRENT_TIMESTAMP WHERE id = ?`, [id]);
  },

  // Audit History Method
  addHistory: async (taskId, summary) => {
    const sql = `INSERT INTO task_history (task_id, change_summary) VALUES (?, ?)`;
    return await runQuery(sql, [taskId, summary]);
  },

  // Fetch history for a specific task
  getHistory: (taskId) => {
    return new Promise((resolve, reject) => {
      // FIX: Add secondary sort 'id DESC' to handle events happening in the same second
      const sql = `SELECT * FROM task_history WHERE task_id = ? ORDER BY changed_at DESC, id DESC`;
      
      db.all(sql, [taskId], (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
};

module.exports = TaskModel;